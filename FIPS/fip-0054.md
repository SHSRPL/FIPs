---
fip: "0054"
title: Filecoin EVM runtime (FEVM)
author: Ra√∫l Kripalani (@raulk), Steven Allen (@stebalien)
discussions-to: <URL>
status: Draft
type: Technical Core
category: Core
created: 2022-12-02
spec-sections:
requires: N/A
replaces: N/A
---

# Filecoin EVM compatibility (FEVM)

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [Simple Summary](#simple-summary)
- [Abstract](#abstract)
- [Change Motivation](#change-motivation)
- [Specification: Filecoin EVM (FEVM) Runtime Actor](#specification-filecoin-evm-fevm-runtime-actor)
  - [Installation and wiring](#installation-and-wiring)
  - [Instantiatable actor](#instantiatable-actor)
  - [State](#state)
  - [Contract storage (KAMT)](#contract-storage-kamt)
  - [Actor interface (methods)](#actor-interface-methods)
    - [`Constructor` (method number 0)](#constructor-method-number-0)
    - [`InvokeContract` (method number 2)](#invokecontract-method-number-2)
    - [`GetBytecode` (method number 3)](#getbytecode-method-number-3)
    - [`GetStorageAt` (method number 4)](#getstorageat-method-number-4)
    - [`InvokeContractDelegate` (method number 5)](#invokecontractdelegate-method-number-5)
    - [`HandleFilecoinMethod` (general handler for method numbers >= 1024)](#handlefilecoinmethod-general-handler-for-method-numbers--1024)
  - [Addressing](#addressing)
  - [Opcode support](#opcode-support)
    - [Opcodes without remarks](#opcodes-without-remarks)
    - [Opcodes with remarks](#opcodes-with-remarks)
  - [Precompiles](#precompiles)
    - [Ethereum precompiles](#ethereum-precompiles)
    - [Filecoin precompiles](#filecoin-precompiles)
  - [Other considerations](#other-considerations)
    - [Historical support](#historical-support)
    - [Transaction types](#transaction-types)
    - [Native currency](#native-currency)
  - [Errors](#errors)
- [Specification: Filecoin Virtual Machine changes](#specification-filecoin-virtual-machine-changes)
  - [Environmental data during FVM Machine construction](#environmental-data-during-fvm-machine-construction)
  - [[EIP-155] Chain IDs of Filecoin networks](#eip-155-chain-ids-of-filecoin-networks)
  - [Added syscalls](#added-syscalls)
  - [Removed syscalls](#removed-syscalls)
  - [Changed syscalls](#changed-syscalls)
  - [New externs](#new-externs)
  - [New general exit codes](#new-general-exit-codes)
- [Specification: Client changes](#specification-client-changes)
  - [Tipset CID](#tipset-cid)
- [Design Rationale](#design-rationale)
  - [Flat vs. nested contract deployment model](#flat-vs-nested-contract-deployment-model)
  - [Optimizing EVM storage](#optimizing-evm-storage)
- [Backwards Compatibility](#backwards-compatibility)
- [Test Cases](#test-cases)
- [Security Considerations](#security-considerations)
- [Incentive Considerations](#incentive-considerations)
- [Product Considerations](#product-considerations)
  - [Gas](#gas)
  - [Notable differences between FEVM and EVM for smart contract developers](#notable-differences-between-fevm-and-evm-for-smart-contract-developers)
  - [Chain explorer guidance](#chain-explorer-guidance)
  - [Impact of in-place upgrades](#impact-of-in-place-upgrades)
- [Implementation](#implementation)
- [Appendix A: Upgrades](#appendix-a-upgrades)
- [Copyright](#copyright)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Simple Summary

We introduce a new built-in actor: the Filecoin EVM (FEVM) runtime actor, capable of running EVM smart contracts on top of the Filecoin Virtual Machine.
We also introduce various changes to the Filecoin Virtual Machine and to client implementations, necessary to support the operation of this new actor.

## Abstract

The Filecoin EVM (FEVM) runtime built-in actor runs EVM smart contracts compatible with the [Ethereum Paris fork].
It achieves this by embedding a special-purpose EVM interpreter, implementing the integration logic with the Filecoin environment, and translating all state I/O to the underlying IPLD model.
The EVM interpreter supports all required opcodes and Ethereum precompiles to strive for maximal portability.
Functional and technical departures from Ethereum's standard expectations are documented herein.

The FEVM runtime actor motivates some changes in the FVM.
Syscalls are modified, syscalls are added, new environmental data is required, and new exit codes are created.
The concept of a TipsetCID is also introduced formally, and is of required implementation by clients.

This FIP is dependent on [FIP-0048] (f4 address class), [FIP-0049] (Actor events), and [FIP-0055] (Supporting Ethereum Accounts, Addresses, and Transactions).

## Change Motivation

A basic requirement to achieve EVM compatibility is to be able to run EVM smart contracts.
Given the inability to deploy user-defined Wasm actors (arriving at a later stage of the FVM roadmap), we introduce this capability by adding a new built-in actor to the network.
This actor is accompanied by FVM and client changes necessary for functional completeness.

## Specification: Filecoin EVM (FEVM) Runtime Actor

The FEVM runtime actor is the Filecoin built-in actor that _hosts_ and _executes_ EVM bytecode. It contains:

1. An embedded EVM interpreter.
   It processes EVM bytecode handling every instruction according to EVM expectations, with functional departures described herein.
2. The integration logic connecting the EVM interpreter with the Filecoin environment, chain, and virtual machine (FVM).
3. A collection of Ethereum and Filecoin-specific precompiles, as specified below.

### Installation and wiring

On the migration for the network upgrade where this FIP goes live:

1. The Wasm bytecode for the EVM runtime actor is loaded onto the node's blockstore.
2. Its CodeCID is linked to the System actor's state under the key `"evm"`.
3. An Ethereum Account actor (as per [FIP-0055]) is created in the state tree with balance zero, nonce zero, and delegated address `f410faaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaonc6iji`, corresponding to the [Ethereum zero address](#ethereum-zero-address).

### Instantiatable actor

The Filecoin EVM runtime is an actor that can be instantiated by users (and therefore, not a singleton actor).
A new instance is to be created for each EVM smart contract deployed on the network.
Instantiation can only originate in the Ethereum Address Manager (EAM), as defined in [FIP-0055], who assigns an f410 subaddress prior to creating the actor via the Init actor, as per standard Filecoin mechanics.

At the time of writing, this makes the EVM runtime actor comparable to the Miner, Payment Channel, and Multisig built-in actors, and unlike the Storage Power, Storage Market, Cron, and other singleton built-in actors.

### State

The state of the EVM runtime actor is as follows:

```rust
pub struct State {
    /// The EVM contract bytecode resulting from calling the
    /// initialization code (init code) by the constructor.
    pub bytecode: Cid,

    /// The EVM contract state dictionary.
    /// All EVM contract state is a map of U256 -> U256 values.
    ///
    /// Root of KAMT<U256, U256>
    pub contract_state: Cid,

    /// The EVM nonce used to track how many times CREATE or
    /// CREATE2 have been called.
    pub nonce: u64,

    /// Possibly a tombstone if this actor has been self-destructed.
    pub tombstone: Option<Tombstone>
}
```

### Contract storage (KAMT)

EVM storage (u256 => u256 map) is backed by a specialized data structure based on the [Filecoin HAMT]: the fixed size Keyed AMT (KAMT).
This data structure is more mechanically sympathetic to typical EVM storage read and write patterns (refer to [Design Rationale](#design-rationale) for more detail).
`SLOAD` and `SSTORE` EVM opcodes map to reads and writes onto this KAMT, respectively, and ultimately to `ipld` syscalls specified in [FIP-0030].

This is how the KAMT compares to its Filecoin HAMT:

1. **Key length.**
   The HAMT uses 256-bit hashed keys. With the KAMT it is possible to specify an arbitrary key length.
3. **Key content.**
   The HAMT assumes arbitrary keys, and hashes them on read and writes.
   The KAMT obviates the need for key hashing and assumes the caller has hashed keys to a fixed-width binary format.
4. **Overlapping prefixes and extensions**.
   The HAMT assumes hashing function that results in unpredictable keys which are uniformly distributed across the keyspace.
   The KAMT optimizes for long overlaps in keys.
   Whenever a node in the data structure is full, it looks for the longest common prefix of the keys and uses extensions to skip multiple levels in the tree that would otherwise only contain a single pointer pointing at the next level.

Contrary to traditional EVM storage, the KAMT is an enumerable data structure.
However, no operations are provided for smart contracts to enumerate keys, at least not at this stage.
This useful property merely facilitates external observability and debuggability.

### Actor interface (methods)

The Filecoin EVM runtime actor offers these entrypoints, each of which handles messages sent with the specified Filecoin method numbers.

#### `Constructor` (method number 0)

Initializes a new EVM smart contract with some init bytecode supplied as a constructor parameter.

It is only be invocable by the Ethereum Address Manager (EAM), specified in [FIP-0055], indirectly via the Init actor.
This precondition is validated by checking that an f4 address with namespace `10` (corresponding to the EAM) was assigned to the current actor, prior to its `Constructor` method being called.

The Constructor runs the init bytecode with the EVM interpreter, and populates the actor's state accordingly:

- `bytecode` field: the execution bytecode is stored as a raw IPLD block and linked by CID from this field.
- `contract_state` field: contains the root CID of the storage [KAMT](#kamt-specification) resulting from `SSTORE` operations during construction.
- `nonce` field: set to 0, unless any calls to CREATE or CREATE2 happen during initialization.

_Input parameters_

```rust
// DAG-CBOR tuple encoded.
pub struct ConstructorParams {
    /// The actor's "creator" (specified by the EAM).
    pub creator: EthAddress,
    /// The EVM initcode that will construct the new EVM actor.
    pub initcode: RawBytes,
}
```

_Return value_

None.

_Errors_

// TODO

#### `InvokeContract` (method number 2)

Invokes an EVM smart contract by loading the execution bytecode from state, and dispatching input data to it.

The input data is expected to be framed as a DAG-CBOR byte string.
This method unframes it before handing it over to the contract (subsequently retrievable through CALLDATA* opcodes).
This method is universally callable.

_Input parameters_

Raw bytes, encoded as a DAG-CBOR byte string.

_Return value_

Raw bytes, encoded as a DAG-CBOR byte string.

_Errors_

// TODO

#### `GetBytecode` (method number 3)

Returns the CID of the contract's EVM bytecode block, adding it to the caller's reachable set.
This method is used internally to resolve `EXTCODE*` opcodes.

_Input parameters_

None.

_Return value_

CID of the contract's bytecode as stored in state.

_Errors_

// TODO

#### `GetStorageAt` (method number 4)

Returns the value stored at the specified EVM storage slot.
This method exists purely for encapsulation purposes; concretely, to enable tools to inspect EVM storage without having to parse the state object, or understand the KAMT.
Calling is restricted to `f00` (system actor), and therefore cannot be invoked via messages or internal sends.
It can be used by the Ethereum JSON-RPC `eth_getStorageAt` operation to resolve requests by constructing a local call and processing it with the FVM.

_Input parameters_

```rust
// DAG-CBOR tuple encoded.
pub struct GetStorageAtParams {
    pub storage_key: U256, // encoded as a DAG-CBOR byte string
}
```

_Return value_

Storage value (U256), encoded as a DAG-CBOR byte string.
If the storage key doesn't exist, it returns a 0-filled 32-byte array.

_Errors_

- Exit code `USR_FORBIDDEN` (18) when not called by address f00.
- Exit code `USR_ASSERTION_FAILED` (24) on internal errors.

#### `InvokeContractDelegate` (method number 5)

Recursive invocation entrypoint backing calls made through the `DELEGATECALL` opcode.
Only callable by self.

_Input parameters_

```rust
// DAG-CBOR tuple encoded.
pub struct DelegateCallParams {
    /// CID of the EVM bytecode to invoke under self's context.
    pub code: Cid,
    /// The contract invocation parameters
    pub input: Vec<u8>, // encoded as a DAG-CBOR byte string
}
```

_Return value_

Same as `InvokeContract`.

_Errors_

- Exit code `USR_FORBIDDEN` (18) when caller is not self.
- // TODO

#### `HandleFilecoinMethod` (general handler for method numbers >= 1024)

Filecoin native messages carrying a method number above or equal to 1024 (a superset of the public range of the [FRC42 calling convention]) are processed by this entrypoint.
This entrypoint creates synthetic EVM input data satisfying the Solidity call convention for this method signature:

```solidity
// Function selector: 0x868e10c4
// Args: method number, params codec, raw params
// Returning: bytes
handle_filecoin_method(uint64,uint64,bytes)
```

For more information, see the [Solidity Contract ABI Specification](https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#contract-abi-specification) for more information.

This path enables processing transactions sent from non-Ethereum sending sites, e.g. built-in actors, Filecoin wallets, and future Wasm actors, with arbitrary Filecoin method numbers.

_Input parameters_

Raw bytes, assumed to be DAG-CBOR byte string.

_Return value_

Raw bytes, encoded as a DAG-CBOR byte string.

### Addressing

EVM smart contracts deployed on Filecoin calling opcodes that take addresses as parameters can use two types of addresses.
Both these addresses conform to EVM addressing expectations (160-bit width):

1. Masked Filecoin ID addresses.
2. Actual Ethereum addresses.

**Masked Filecoin ID addresses** are addresses conforming to Ethereum's type (160-bit) that encode Filecoin ID addresses.
They are distinguished through a byte mask.
The high byte is `0xff` (discriminator), followed by thirteen 0 bytes of padding, then the uint64 ID of the actor.

```
|- disc -|    |----- padding ------|    |----- actor id -----|
0xff       || 0000000000000000000000 || <uint64 ID big endian>
```

**Ethereum addresses** are all addresses that do not satisfy the above mask.
They are converted to `f410` addresses as per the conversion specified in [FIP-0055].
This includes the Ethereum Zero Address.
Precompile addresses are an exception.
Calls to precompiles are handled internally inside the EVM runtime actor and do not incur in `send` syscalls.

### Opcode support

All opcodes from the [Ethereum Paris hard fork] are supported.
This section enumerates all supported opcodes, noting functional departures from their Ethereum counterparts, as well as relevant remarks about how they operate.
Opcodes are referred to by their mnemonic name.

#### Opcodes without remarks

These opcodes are handled locally within the EVM interpreter and have no departures from their original behaviour in Ethereum.

- Arithmetic family: ADD, MUL, SUB, DIV, SDIV, MOD, SMOD, ADDMOD, MULMOD, EXP, SIGNEXTEND.
- Boolean operators: LT, GT, SLT, SGT, EQ, ISZERO, AND, OR, XOR, NOT.
- Bitwise operations: BYTE, SHL, SHR, SAR.
- Control flow: STOP, JUMPDEST, JUMP, JUMPI, PC, STOP, RETURN, INVALID.
- Parameters: CALLDATALOAD, CALLDATASIZE, CALLDATACOPY, RETURNDATASIZE, RETURNDATACOPY.
- Stack manipulation: POP, PUSH{1..32}, DUP{1..32}, SWAP{1..16}.

#### Opcodes with remarks

**Memory: MLOAD, MSTORE, MSTORE8, MSIZE.**
EVM memory is modelled as an object inside the interpreter, ultimately backed by Wasm memory.
Usage of of these instructions incurs in Wasm memory expansion costs as per FIP-TODO.

**Accessors: ADDRESS.**
Returns the masked Filecoin ID address of the executing contract.

**Accessors: BALANCE.**
Returns the filecoin balance of the contract, in atto precision (same precision as Ethereum).

**Accessors: ORIGIN.**
Returns the masked Filecoin ID address of the account where the chain message originated.

**Accessors: CALLER.**
Returns the masked Filecoin ID address of the immediate caller of the contract.

**Accessors: CALLVALUE.**
Returns the filecoin value sent in the message, in atto precision (same precision as Ethereum).

**Accessors: GASPRICE.**
Returns the base fee plus the gas premium, in atto precision (same precision as Ethereum).
This is functionally equivalent to Ethereum's `GASPRICE` definition following [EIP-1559], which is to return the `effective_gas_price`, defined as:

```
effective_gas_price = priority_fee_per_gas + block.base_fee_per_gas
```

**Accessors: BLOCKHASH.**
Returns hash within the tipset CID of the requested epoch, with a maximum lookback of 256 epochs, truncated to preserve the left-most 32 bytes.
TODO: null rounds.

**Accessors: COINBASE.**
Nil implementation. Returns a fixed 0x0 value.

**Accessors: TIMESTAMP.**
Returns the timestamp of the epoch being executed, as a Unix timestamp, as supplied by the client during Machine construction.

**Accessors: NUMBER.**
Returns the epoch being executed.

**Accessors: PREVRANDAO (former DIFFICULTY, see [EIP-4399]).**
Returns beacon randomness for the current epoch, by calling the `rand::get_beacon_randomness` syscall as defined in [FIP-0030], supplying:

- domain separation tag `10`
- entropy equivalent to the UTF-8 bytes of string "prevrandao"

**Accessors: GASLIMIT.**
Returns the fixed number 10e9 (10B gas).

**Accessors: CHAINID.**
Returns the [EIP-155 Chain ID](#eip-155-chain-ids-of-filecoin-networks) of the current network.

**Accessors: BASEFEE.**
TODO.

**Accessors: SELFBALANCE.**
TODO.

**Accessors: GAS.**
TODO.

**Control flow: REVERT.**
TODO.

**Hashing: KECCAK256.**
Makes a syscall to `crypto::hash` with the supplied preimage and the Keccak-256 multihash.

**Logging: LOG{0..4}.**

Logs in the Ethereum Virtual Machine are emitted through `LOG{0..4}` opcodes.
Each variant takes the specified number of topics (indexed).
All variants take a single memory slice referring to the data (non indexed).

We define `LOG{0..4}` opcodes to emit [FIP-0049] compliant actor events conforming to the following template:

```rust
// Values are encoded as DAG-CBOR byte strings.
ActorEvent {
    entries: [
        (0x03, "t1", <first topic word>),   // when LOG1, LOG2, LOG3, LOG4
        (0x03, "t2", <second topic word>),  // when LOG2, LOG3, LOG4
        (0x03, "t3", <third topic word>),   // when LOG3, LOG4
        (0x03, "t4", <fourth topic word>),  // when LOG4
        (0x02, "p", <data word>),
    ],
}
```

**Storage: SLOAD, SSTORE.**
TODO.

**Lifecycle: CREATE.**
TODO.

**Lifecycle: CREATE2.**
TODO.

**Lifecycle: SELFDESTRUCT.**
TODO.

**Calls: CALL.**
TODO.

**Calls: CALLCODE.**
TODO.

**Calls: DELEGATECALL.**
TODO. InvokeContractDelegate.

**Calls: STATICCALL.** 
TODO. Read-only mode.

**External code: EXTCODESIZE.**
TODO.

**External code: EXTCODECOPY.**
TODO.

**External code: EXTCODEHASH.**
TODO.

### Precompiles

There are two kinds of precompiles available to EVM smart contracts running within the FEVM runtime actor:

- Ethereum precompiles
- Filecoin precompiles

#### Ethereum precompiles

The FEVM runtime actor supports all [Ethereum precompiles] available in the Ethereum Paris fork.
These precompiles sit at their original Ethereum addresses.
There are no functional departures with respect to their original behavior.
Refer to Ethereum documentation for more information.

| Ethereum Address | Precompile   |
| ---------------- | ------------ |
| `0x01`           | `ecRecover`  |
| `0x02`           | `SHA2-256`   |
| `0x03`           | `RIPEMD-160` |
| `0x04`           | `identity`   |
| `0x05`           | `modexp`     |
| `0x06`           | `ecAdd`      |
| `0x07`           | `ecMul`      |
| `0x08`           | `ecPairing`  |
| `0x09`           | `blake2f`    |

#### Filecoin precompiles

The following Filecoin-specific precompiles are exposed to EVM smart contracts at the designated addresses:

| Ethereum Address | Precompile           |
| ---------------- | -------------------- |
| `0x0a`           | `resolve_address`    |
| `0x0b`           | `lookup_address`     |
| `0x0c`           | `get_actor_code_cid` |
| `0x0d`           | `get_randomness`     |
| `0x0e`           | `call_actor`         |

**Precompile `0x0a`: `resolve_address`**

// TODO

_Call layout_

_Errors_

**Precompile `0x0b`: `lookup_address`**

// TODO

_Call layout_

_Errors_

**Precompile `0x0c`: `get_actor_code_cid`**

// TODO

_Call layout_

_Errors_

**Precompile `0x0d`: `get_randomness`**

// TODO

_Call layout_

_Errors_

**Precompile `0x0e`: `call_actor`**

// TODO

_Call layout_

_Errors_

### Other considerations

#### Historical support

Historical Ethereum behaviors are not supported.
EVM opcode and precompile support is restricted to the Ethereum Paris fork.

#### Transaction types

The only supported Ethereum transaction type is the EIP-1559 transaction (type 2 in the RLP-encoded transaction format).
Such transactions carry a gas fee cap and a gas premium, both of which map cleanly to Filecoin's message model.

#### Native currency

The native currency of the Filecoin EVM runtime is filecoin.
This environment has no dependence to, or understanding of, Ether as a currency.

### Errors

TODO.

## Specification: Filecoin Virtual Machine changes

### Environmental data during FVM Machine construction

New environmental data is required by the FVM to satisfy new data returned in syscalls:

- [EIP-155] [Chain ID](#eip-155-chain-ids-of-filecoin-networks) of the network.
- Timestamp of the execution epoch.

### [EIP-155] Chain IDs of Filecoin networks

We define the following [EIP-155] Chain IDs for Filecoin networks:

- Mainnet: 314
- Hyperspace testnet: 3141
- Wallaby testnet: 31415
- Calibration testnet: 314159
- Butterfly testnet: 3141592
- Local/private testnets: 31415926

These Chain IDs have been registered in the [`ethereum-lists/chains`] registry, which in turn is prepared for [CAIP-2] compliance.

### Added syscalls

**`network::context`**

```rust
#[repr(packed, C)]
pub struct NetworkContext {
   /// The current epoch.
   pub epoch: ChainEpoch,
   /// The current time (seconds since the unix epoch).
   pub timestamp: u64,
   /// The current base-fee.
   pub base_fee: TokenAmount,
   /// The network version.
   pub network_version: u32,
}

/// Returns the details about the network.
///
/// # Errors
///
/// None
pub fn context() -> Result<NetworkContext>;
```

**`network::tipset_cid`**

```rust
/// Retrieves a tipset's CID within the last finality, if available
///
/// # Arguments
///
/// - `epoch` the epoch being queried.
/// - `ret_off` and `ret_len` specify the location and length of the buffer into which the
///   tipset CID will be written.
///
/// # Returns
///
/// Returns the length of the CID written to the output buffer.
///
/// # Errors
///
/// | Error               | Reason                                       |
/// |---------------------|----------------------------------------------|
/// | [`IllegalArgument`] | specified epoch is negative or in the future |
/// | [`LimitExceeded`]   | specified epoch exceeds finality             |
pub fn tipset_cid(
   epoch: i64,
   ret_off: *mut u8,
   ret_len: u32,
) -> Result<u32>;
```

**`actor::lookup_address`**

```rust
/// Looks up the "predictable" address of the target actor.
///
/// # Arguments
///
/// `addr_buf_off` and `addr_buf_len` specify the location and length of the output buffer in
/// which to store the address.
///
/// # Returns
///
/// The length of the address written to the output buffer, or 0 if the target actor has no
/// predictable address.
///
/// # Errors
///
/// | Error               | Reason                                                           |
/// |---------------------|------------------------------------------------------------------|
/// | [`NotFound`]        | if the target actor does not exist                               |
/// | [`BufferTooSmall`]  | if the output buffer isn't large enough to fit the address       |
/// | [`IllegalArgument`] | if the output buffer isn't valid, in memory, etc.                |
pub fn lookup_address(
   actor_id: u64,
   addr_buf_off: *mut u8,
   addr_buf_len: u32,
) -> Result<u32>;
```

**`actor::balance_of`**

```rust
/// Returns the balance of the actor at the specified ID.
///
/// # Arguments
///
/// `actor_id` is the ID of the actor whose balance is to be returned.
///
/// # Returns
///
/// The balance of the specified actor, or 0 if the actor doesn't exist.
///
/// # Errors
///
/// TODO
/// 
pub fn balance_of(
   actor_id: u64
)  -> Result<super::TokenAmount>;
```

**`actor::next_actor_address`**

```rust
/// Generates a new actor address for an actor deployed by the calling actor.
///
/// **Privileged:** May only be called by the init actor.
pub fn next_actor_address(obuf_off: *mut u8, obuf_len: u32) -> Result<u32>;
```

**`crypto::recover_secp_public_key`**

```rust
/// Recovers the signer public key from a signed message hash and its signature.
///
/// Returns the public key in uncompressed 65 bytes form.
///
/// # Arguments
///
/// - `hash_off` specify location of a 32-byte message hash.
/// - `sig_off` specify location of a 65-byte signature.
///
/// # Errors
///
/// | Error               | Reason                                               |
/// |---------------------|------------------------------------------------------|
/// | [`IllegalArgument`] | signature or hash buffers are invalid                |
pub fn recover_secp_public_key(
   hash_off: *const u8,
   sig_off: *const u8,
) -> Result<[u8; SECP_PUB_LEN]>;
```

**`event::emit_event`**

See [FIP-0049 (Actor events)].

```rust
/// Emits an actor event to be recorded in the receipt.
///
/// Expects a DAG-CBOR representation of the ActorEvent struct.
///
/// # Errors
///
/// | Error               | Reason                                                              |
/// |---------------------|---------------------------------------------------------------------|
/// | [`IllegalArgument`] | entries failed to validate due to improper encoding or invalid data |
pub fn emit_event(
   evt_off: *const u8,
   evt_len: u32,
) -> Result<()>;
```

**`gas::available`**

```rust
/// Returns the amount of gas remaining.
pub fn available() -> Result<u64>;
```

**`vm::exit`**

```rust
/// Abort execution with the given code and optional message and data for the return value.
/// The code and return value are recorded in the receipt, the message is for debugging only.
///
/// # Arguments
///
/// - `code` is the `ExitCode` to abort with.
///   If this code is zero, then the exit indicates a successful non-local return from
///   the current execution context.
///   If this code is not zero and less than the minimum "user" exit code, it will be replaced with
///   `SYS_ILLEGAL_EXIT_CODE`.
/// - `blk_id` is the optional data block id; it should be 0 if there are no data attached to
///   this exit.
/// - `message_off` and `message_len` specify the offset and length (in wasm memory) of an
///   optional debug message associated with this abort. These parameters may be null/0 and will
///   be ignored if invalid.
///
/// # Errors
///
/// None. This function doesn't return.
pub fn exit(code: u32, blk_id: u32, message_off: *const u8, message_len: u32) -> !;
```

**`vm::message_context`**

```rust
#[repr(packed, C)]
pub struct MessageContext {
   /// The current call's origin actor ID.
   pub origin: ActorID,
   /// The caller's actor ID.
   pub caller: ActorID,
   /// The receiver's actor ID (i.e. ourselves).
   pub receiver: ActorID,
   /// The method number from the message.
   pub method_number: MethodNum,
   /// The value that was received.
   pub value_received: TokenAmount,
   /// The current gas premium
   pub gas_premium: TokenAmount,
   /// The current gas limit
   pub gas_limit: u64,
   /// Flags pertaining to the currently executing actor's invocation context.
   pub flags: ContextFlags,
}

/// Returns the details about the message causing this invocation.
///
/// # Errors
///
/// None
pub fn message_context() -> Result<MessageContext>;
```

### Removed syscalls

`vm::abort` is replaced by the more general syscall `vm::exit`, which can accept a zero exit code, as well as return data on error.

`vm::context` is renamed to `vm::mesage_context`.

`network::base_fee` is superseded by `network::context`, which returns the base fee, in addition to other fields.

`actor::new_actor_address` is replaced by `actor::next_actor_address`.

### Changed syscalls

- TODO Send takes gas limit and flags.

### New externs

// TODO tipset CID syscall

### New general exit codes

- USR_READ_ONLY, code 25: The requested operation cannot be performed in "read-only" mode.

## Specification: Client changes

### Tipset CID

TODO.

## Design Rationale

### Flat vs. nested contract deployment model

Early on, we had to choose the broad architecture by which EVM smart contracts would become an entity on-chain.
We considered two large architectural options:

1. A flat deployment model, where each EVM smart contract is an independent actor on-chain, with its own entry in the state tree, and its own address set.
2. A nested deployment model, where a singleton built-in actor would contain the entirety of the EVM domain within it, with some form of internal fragmentation to model every smart contract as an independent entity within a monolithic state.

The choice went hand-in-hand with the addressing model, since we needed to assign and recognize Ethereum addresses either way.
With (1), we'd need to find a way to delegate addressing to another actor that controlled a discretionary address space.
With (2), addressing could be _recursive_, where the address first referred to the singleton actor, followed by an opaque component to be interpreted by such actor for internal routing.

This choice is a foundational one, as it defines the architectural trajectory of the Filecoin network for years to come, insofar programmability is concerned.
These are the main reasons we chose to adopt (1):

1. It places EVM smart contracts, as well as any other future foreign program, at equal footing and hierarchical level as any other actor, such as built-in actors, eventual user-deployed Wasm actors, and other future entities.
2. It physically isolates state between actors through a shared-nothing model.
   This simplifies state management, makes state more granular, prevents undesired churn on update, eliminates the possibility of side effects, and contagion of IO overheads across smart contracts.
3. It enables future versioning of the EVM runtime with explicit opt-in from developers at the contract level (i.e. optionality).
4. It forces us to introduce general protocol advancements to facilitate seamless interoperability across supported runtimes, versus hyperspecialization within runtimes.

See the discussion under [filecoin-project/ref-fvm#742](https://github.com/filecoin-project/ref-fvm/issues/742) for further context.

### Optimizing EVM storage

The EVM contract storage model makes no assumptions about concrete key patterns, slot placement of state variables, nor slot addressing in the case of complex and/or dynamic types such as structs, maps, or arrays.
Languages such as Solidity and Vyper are responsible mapping state to EVM storage by adopting a concrete storage layout for its types.
When designing the KAMT, we optimized for the [Solidity storage layout], such that:

1. Contiguous slots are adjacently placed within the same node as adjacent pointers, or in adjacent nodes if overflowing.
2. Access to slots sharing common prefixes is shortcut through extensions that skip otherwise-sparse tree levels.

Optimizing for Solidity makes sense because it is, by far, the most popular Ethereum smart contract programming language.
Furthermore, [Vyper has adopted Solidity's storage layout](https://github.com/vyperlang/vyper/issues/769) for complex and dynamic state types.

## Backwards Compatibility

Built-in actors must be updated to absorb the syscall changes specified herein to retain backwards compatibility.
This has been taken care of during the implementation of this FIP.

## Test Cases

See integration tests in [ref-fvm], as well as unit and integration tests of the [EVM runtime actor](https://github.com/filecoin-project/builtin-actors/tree/next/actors/evm/tests).

## Security Considerations

This FIP enables the deployment of user-defined code to the Filecoin network for the first time, in the form of smart contracts specified by EVM bytecode.
This opens up entire new dimensionalities of use in the Filecoin network an entire new dimension of use for the Filecoin networkentire new dimension of use 

## Incentive Considerations

No concrete incentive considerations emerge from this technical FIP per-se, other than noting that 

## Product Considerations

### Gas

Gas metering and execution halt are performed according to the Filecoin gas model.
EVM smart contracts accrue:

- Execution costs: resulting from the handling of Wasm instructions executed during the interpretation of the EVM bytecode, _as well as_ the EVM runtime actor logic (e.g. method dispatch, payload handling, and more).
- Syscall and extern costs: resulting from the syscalls made by the EVM opcode handlers, _and_ the EVM runtime actor logic itself.
- Memory expansion costs: resulting from the allocation of Wasm memory pages.
- Storage costs: resulting from IPLD state reads and accesses, directly by the smart contract as a result of `SSTORE` and `SLOAD` opcodes, or indirectly by the EVM runtime actor during dispatch or opcode handling.

As specified above, gas-related opcodes such as `GAS` and `GASLIMIT` return Filecoin gas, coercing their natural u64 type to u256 (EVM type).
The gas limit supplied to the `CALL`, `DELEGATECALL` and `STATICCALL` opcodes is also Filecoin gas.

Consequently, contracts ported from Ethereum that use literal gas values (e.g. the well known 2300 gas price for bare value transfers) may require adaptation, as these gas values won't directly translate into the Filecoin gas model.

### Notable differences between FEVM and EVM for smart contract developers

### Chain explorer guidance

### Impact of in-place upgrades

The EVM runtime actor backing EVM smart contracts may be upgraded through future migrations.
Upgrades will impact gas costs in hard-to-predict ways, with compute gas being the most sensitive component.
We discourage smart contract developers to rely on specific gas values in their contract logic.
This includes gas limits passed in `*CALL*` operations. While the system honors those limits, costs will change across upgrades.

## Implementation

At the time of writing, the EVM runtime actor implementation resides in the [`next` branch of `ref-fvm`](https://github.com/filecoin-project/builtin-actors/tree/next/actors/evm).

## Appendix A: Upgrades

TODO.

## Copyright

Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).


[`filecoin-project/builtin-actors`]: https://github.com/filecoin-project/builtin-actors
[Contract ABI spec]: https://docs.soliditylang.org/en/v0.5.3/abi-spec.html
[EIP-155]: https://eips.ethereum.org/EIPS/eip-155
[EIP-1559]: https://eips.ethereum.org/EIPS/eip-1559
[EIP-4399]: https://eips.ethereum.org/EIPS/eip-4399
[Ethereum Paris hard fork]: https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/
[Ethereum precompiles]: https://www.evm.codes/precompiled
[FIP-0048]: https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0048.md
[FIP-0049]: https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0049.md
[FRC42 calling convention]: https://github.com/filecoin-project/FIPs/blob/master/FRCs/frc-0042.md
[Solidity storage layout]: https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html
[`ethereum-lists/chains`]: https://github.com/ethereum-lists/chains
[CAIP-2]: https://github.com/ChainAgnostic/CAIPs/blob/master/CAIPs/caip-2.md